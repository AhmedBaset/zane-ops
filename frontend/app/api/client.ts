import createClient, { type Middleware } from "openapi-fetch";
import { excerpt } from "~/utils";
import type { paths } from "./v1"; // generated by openapi-typescript

const throwErrorOnServerError: Middleware = {
  async onResponse(response) {
    if (response.status > 499) {
      let data: string;
      if (response.headers.get("content-type") === "application/json") {
        data = JSON.stringify(await response.json());
      } else {
        data = excerpt(await response.text(), 1000);
      }
      // intermitent server error, we throw here so that react query retry the query at least once
      throw new Error(`Server Error from API: ${data}`);
    }
    return response;
  }
};

const apiClient = createClient<paths>({
  baseUrl: "/"
});

apiClient.use(throwErrorOnServerError);

type RequestMethod = "post" | "put" | "get" | "delete" | "patch";

type ExtractRequestBody<
  TPaths,
  TPath extends keyof TPaths,
  TMethod extends RequestMethod
> = TPaths[TPath] extends Record<TMethod, infer TOperation>
  ? // Check if there's a 'post' or 'put' method
    TOperation extends {
      requestBody?: { content: { "application/json": infer TRequestBody } };
    } // Navigate directly to '["content"]["application/json"]'
    ? TRequestBody
    : never
  : never;

type ExtractRequestParams<
  TPaths,
  TPath extends keyof TPaths,
  TMethod extends RequestMethod
> = TPaths[TPath] extends Record<TMethod, infer TOperation>
  ? TOperation extends {
      parameters?: { query: infer TRequestParams };
    }
    ? TRequestParams
    : never
  : never;

// Helper type to filter paths that contain either POST or PUT operations
type PathsThatContainMethod<TPaths, TMethod extends RequestMethod> = {
  [K in keyof TPaths]: TPaths[K] extends Record<TMethod, unknown> ? K : never;
}[keyof TPaths];

export type RequestInput<
  TMethod extends RequestMethod,
  TPath extends PathsThatContainMethod<paths, TMethod>
> = ExtractRequestBody<paths, TPath, TMethod>;

export type RequestParams<
  TMethod extends RequestMethod,
  TPath extends PathsThatContainMethod<paths, TMethod>
> = ExtractRequestParams<paths, TPath, TMethod>;

type ExtractResponse<
  TPaths,
  TPath extends keyof TPaths,
  TMethod extends RequestMethod,
  TStatusCode extends number
> = TPaths[TPath] extends Record<TMethod, infer TOperation>
  ? // Check if there's a specified method
    TOperation extends {
      responses: Record<
        TStatusCode,
        { content: { "application/json": infer TResponseBody } }
      >;
    } // Navigate directly to the response for the given status code
    ? TResponseBody
    : never
  : never;

export const HTTP_SUCCESS = 200;

export type ApiResponse<
  TMethod extends RequestMethod,
  TPath extends PathsThatContainMethod<paths, TMethod>,
  TStatusCode extends number = typeof HTTP_SUCCESS
> = ExtractResponse<paths, TPath, TMethod, TStatusCode>;

export { apiClient };
